<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuyun&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="liuyun594@github.io/"/>
  <updated>2020-01-11T06:11:15.089Z</updated>
  <id>liuyun594@github.io/</id>
  
  <author>
    <name>liuyun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>win10自带输入法打不出中文标点</title>
    <link href="liuyun594@github.io/2020/01/11/win10%E8%87%AA%E5%B8%A6%E8%BE%93%E5%85%A5%E6%B3%95%E6%89%93%E4%B8%8D%E5%87%BA%E4%B8%AD%E6%96%87%E6%A0%87%E7%82%B9/"/>
    <id>liuyun594@github.io/2020/01/11/win10%E8%87%AA%E5%B8%A6%E8%BE%93%E5%85%A5%E6%B3%95%E6%89%93%E4%B8%8D%E5%87%BA%E4%B8%AD%E6%96%87%E6%A0%87%E7%82%B9/</id>
    <published>2020-01-11T06:08:58.746Z</published>
    <updated>2020-01-11T06:11:15.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直用的是win10自带的输入法，在一次写博客时输入法打不出来中文的标点符号了，后面才发现问题所在，这里说一下问题发生的两种可能情况。</p><a id="more"></a><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>打开了“中文输入时使用英文标点”。关掉即可。</p><p>右击输入法小图标→设置→常规→关闭“中文输入时使用英文标点”</p><p><img src="/images/%E8%BE%93%E5%85%A5%E6%B3%95_case1.jpg" alt="关闭“中文输入时使用英文标点”"></p><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>不小心按到了<code>ctrl+.</code>，切换到了英文标点，再按一次<code>ctrl+.</code>即可。</p><p><img src="/images/%E8%BE%93%E5%85%A5%E6%B3%95_case2.jpg" alt="切换到了英文标点"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直用的是win10自带的输入法，在一次写博客时输入法打不出来中文的标点符号了，后面才发现问题所在，这里说一下问题发生的两种可能情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小技巧" scheme="liuyun594@github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="原创" scheme="liuyun594@github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="小技巧" scheme="liuyun594@github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="输入法" scheme="liuyun594@github.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++模板代码组织方式</title>
    <link href="liuyun594@github.io/2020/01/10/C++%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/"/>
    <id>liuyun594@github.io/2020/01/10/C++%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/</id>
    <published>2020-01-09T16:00:00.000Z</published>
    <updated>2020-01-10T04:52:14.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文讲述了C++中组织模板源代码的几种方式——包含模型、显示实例化和分离模型。来源是《C++ templates》。本文中的部分代码可从<a href="https://pan.baidu.com/s/1dBUlZfFRHU5hJl-RSuf6Nw" target="_blank" rel="noopener">此链接</a>下载，提取码为4xxq（非书中所带，有错请海涵）。</p><a id="more"></a><h3 id="1-包含模型"><a href="#1-包含模型" class="headerlink" title="1. 包含模型"></a>1. 包含模型</h3><p>我们可以用几种方法来组织模板源代码，最常用的方法是<strong>包含模型</strong>(inclusion model)。</p><h4 id="1-1-链接器错误"><a href="#1-1-链接器错误" class="headerlink" title="1.1 链接器错误"></a>1.1 链接器错误</h4><p>大多数C和C++程序员会这样组织他们的非模板代码：</p><ul><li>类(class)和其他类型(other types)都被放在一个头文件中。通常而言，头文件是一个扩展名为.hpp（或者.H、.h、.hh、.hxx）的文件</li><li>对于全局变量和（非内联）函数，只有声明放在头文件中，定义则位于dot-C文件，通常而言，dot-C文件是指扩展名为.cpp（或者.C、.c、.cc、.cxx）的文件。</li></ul><p>这样一切都可以正常运作了。所需的类型定义在整个程序中都是可见的；并且对于变量和函数而言，连接器也不会给出重复定义的错误。</p><p>当牢记了这种约定之后，刚开始接触模板的程序员却总会对这种约定发出抱怨，因为它令链接器产生了一个错误。我们可以通过下面的错误小程序来说明一点。利用上面针对普通代码的约定，我们应该在一个头文件中声明模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  error/myfirst.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYFIRST_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIRST_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_typeof</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//MYFIRST_HPP</span></span></span><br></pre></td></tr></table></figure><p>print_typeof()是一个辅助函数模板的声明，它输出某些类型信息。该函数模板的实现被放在下面的dot-C文件里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   error/myfirst.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfirst.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的实现/定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_typeof</span><span class="params">(T <span class="keyword">const</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在另一个dot-C文件里使用这个模板，并把模板声明包含进这个文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  error/myfristmain.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfirst.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ice = <span class="number">3.0</span>;</span><br><span class="line">    print_typeof(ice);<span class="comment">//调用参数类型为double 的函数模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数C++编译器都会顺利地接收这个程序：但是链接器可能会报错，提示找不到函数print_typeof()的定义。</p><p><img src="/images/%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF.jpg" alt="g++链接器报错"></p></br><p>事实上，这个错误的原因在于：函数模板print_typeof()的定义还没有被实例化。为了使模板真正得到实例化，编译器必须知道：应该实例化哪个定义以及要基于那个模板实参来进行实例化。遗憾的是，在前面的例子里，这两部分信息位于分开编译的不同文件里面。因此，当我们的编译器看到print_typeof()调用，但还没有看到基于double实例化的函数定义的时候，它只是假设在别处提供了这个定义，并产生一个指向该定义的引用（让链接器利用该引用来解决这个问题）。另一方面，当编译器处理文件myfirst.cpp的时候，他并没有指出：编译器必须基于特定实参所包含的模板定义进行实例化。</p></br><h4 id="1-2-头文件中的模板"><a href="#1-2-头文件中的模板" class="headerlink" title="1.2 头文件中的模板"></a>1.2 头文件中的模板</h4><p>对于前面的问题，我们通常是采取对待宏或内联函数的解决办法：我们把模板的定义也包含在声明模板的头文件里面，即让定义和声明都为一同一个头文件中。对于上面的例子，我们可以通过把：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfirst.cpp"</span></span></span><br></pre></td></tr></table></figure><p>添加到myfirst.hpp的末尾，或者在每个使用模板的dot-C文件都包含myfirst.cpp。显然，第三种方法就是完全不要myfirst.cpp，然后重写myfirst.hpp，让它同时包含模板声明和模板定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  inclusion_module/myfirst2.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYFIRST_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIRST_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_typeof</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实现/定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_typeof</span><span class="params">(T <span class="keyword">const</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//MYFIRST_HPP</span></span></span><br></pre></td></tr></table></figure><p>我们称模板的这种组织方式为包含模型。通过使用这种模型，你会发现前面的程序可以顺利编译、链接和运行。</p><p>针对这一点，我们可以得出一些结论，<strong>包含模型明显增加了包含头文件myfirst,hpp的开销，这也是包含模型最大的不足之处</strong>。在例子中，主要的开销并不是取决于模板定义本身的大小，而在于模板定义中所包含的哪些头文件（在我们的例子中是&lt;iostream&gt;和&lt;typeinfo&gt;）的大小。你或许已经知道这样会带来成千上万行的代码，因为每个诸如&lt;iostream&gt;的头文件本身都包含了许多类似的模板定义。</p><p>在实际应用中，这是一个很严重的问题，因为它大大增加了编译复杂程序所耗费的时间。然而，现在的程序大多已经不需要在编译和链接上花上几个小时，将来就更不用说了。</p><p>如果不需要考虑创建期的时间问题，建议你尽量使用包含模型来组织模板代码。我们在后面会考察两外两种组织模板的方式，但就我们（《C++ templates》作者）的观点来看，另外两种组织方式的实际缺陷往往比这里所讨论的创建期开销更加严重。当然，这两种组织方式也有其他一些与软件开发的应用方面简介相关的优点。</p><p>从包含模型得出的另一个（更微妙）结论是，非内联函数模板与“内联函数和宏”有一个很重要的区别，那就是非内联函数模板在调用的位置并不会被扩展，而是当他们基于某种类型进行实例化之后，才会产生一份新的（基于该类型的）函数拷贝。因为这（产生函数拷贝）是一个自动化过程，所以在编译结束的时候，编译器可能会在不同的文件里产生两份拷贝，于是，当链接器发现同一个函数具有两种不同的定义时，就会报告一个错误，理论上讲，这并不是我们需要关心的问题，他应该由C++编译系统来解决。而且，事实上大多数情况下都不会出现这种问题，我们根本没有必要太过于在意这个问题。</p><p>最后，我们需要指出的是：在我们例子中应用到普通模板的所有特定，对类模板的成员函数和静态数据成员、成员函数模板也都是适用的。</p></br></br><h3 id="2-显式实例化"><a href="#2-显式实例化" class="headerlink" title="2. 显式实例化"></a>2. 显式实例化</h3><p>包含模型能够确保所有需要的模板都已经实例化。这是因为：当需要进行实例化的时候，C++编译系统会自动产生所对应的实例化体。另外，C++标准还提供了一种手工实例化模板的机制：显式实例化指示符（explicit instantiation directive）。</p><h4 id="2-1-显式实例化的例子"><a href="#2-1-显式实例化的例子" class="headerlink" title="2.1 显式实例化的例子"></a>2.1 显式实例化的例子</h4><p>为了说明手工实例化，让我们回顾那个导致链接器错误的例子。在此，为了避免这个链接期错误，我们可以通过给程序添加下面的文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  inst/myfirstinst.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfirst.cpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基于类型double显式实例化print_typeof()</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> print_typeof&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure><p><strong>显示实例化指示符由关键字template和紧跟其后的我们所需要实例化的实体（可以是类、函数、成员函数等）的声明组成，而且，该声明是一个已经用实参完全替换参数之后的声明。</strong>在我们的例子中，我们针对的是一个普通函数，但该指示也适用于成员函数和静态数据成员。譬如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于int显示实例化MyClass&lt;&gt;的构造函数</span></span><br><span class="line"><span class="keyword">template</span> MyClass&lt;<span class="keyword">int</span>&gt;::MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于int显式实例化函数max();</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span>&amp;, <span class="keyword">int</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>你还可以显示实例化类模板，这样就可以同时实例化它的所有类成员。但有一点需要注意：对于这些在前面已经实例化的成员，就不能再次对它们进行实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于int显示实例化类Stack&lt;&gt;</span></span><br><span class="line"><span class="keyword">template</span> Stack&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于string显示实例化Stack&lt;&gt;的某些成员函数</span></span><br><span class="line"><span class="keyword">template</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::Stack();</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;);</span><br><span class="line"><span class="keyword">template</span> <span class="built_in">std</span>::<span class="built_in">string</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::top() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误：对于前面已经显式实例化过的成员函数，不能再次对它进行显式实例化</span></span><br><span class="line"><span class="keyword">template</span> Stack&lt;<span class="keyword">int</span>&gt;::Stack();</span><br></pre></td></tr></table></figure><p>对于每个不同实体，在一个程序中最多只能有一个显式实例化实体，换句话说，你可以同时显式实例化print_typeof&lt;int&gt;和print_typeof&lt;double&gt;，但在同一个程序中每个指示符都只能出现一次（就是不能出现两个print_typeof&lt;int&gt;）。如果不遵循这条规则，通常都会导致链接错误，链接器会报错：发现了实例化实体的重复定义。</p><p>人工实例化有一个显著的缺点：我们必须仔细跟踪每个需要实例化的实体。对于大项目而言，这种跟踪很快就会带来巨大负担：因此，我们并不建议使用这种方法。</p></br></br><h3 id="3-分离模型"><a href="#3-分离模型" class="headerlink" title="3. 分离模型"></a>3. 分离模型</h3><p>前面给出的两种方法都可以正常工作，也完全符合C++标准。然而，标准还给出了另一种机制：导出模板(export template)。这种机制通常也被称为C++模板的分离模型(separation model)。</p><h4 id="3-1-关键字export"><a href="#3-1-关键字export" class="headerlink" title="3.1 关键字export"></a>3.1 关键字export</h4><p>大体上讲，关键字export的功能使用是非常简单的：在一个文件里面定义模板，并在模板的定义和（非定义的）声明的前面加上关键字export。对于上面的例子，通过使用export，我们会得到下面的函数模板声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  export/myfirst3.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYFIRST_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIRST_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_typeof</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//MYFIRST_HPP</span></span></span><br></pre></td></tr></table></figure><p>即使在模板定义不可见的条件下，被导出的模板也可以正常使用。换句话说，使用模板的位置和模板定义的位置可以在不同的翻译单元中。在我们的例子中，文件myfirst3.hpp现在只是包含模板的成员函数的声明，但对于使用这些成员已经足够了。和刚开始导致编译器报错的那个例子相比，我们只是在代码中添加了关键字export，一切就可以顺利通过了。</p><p>在一个预处理文件内部（就是指在一个翻译单元内部），我们只需要在第一个证明前面标记export关键字就可以了，后面的重新声明会隐式地保留这个export特性。这也是我们不需要修改文件myfirst.cpp的原因所在。就是说，myfirst.cpp文件里面的这个定义是隐式export，因为在它#include的头文件myfirst3.hpp里面，该定义所对应的声明已经被限定为export的了。另一方面，在模板定义中提供一个冗余的export也是可取的，因为这样可以提高代码的可读性。</p><p>实际上关键字export可以应用于函数模板、类模板和成员函数、成员函数模板和类模板的静态数据成员。另外，它还可以用于类模板的声明，这意味着每个可导出的类成员都被看做可导出实体，但类模板本身实际上并没有被导出（因此，类模板的定义仍需要出现在头文件中）。你仍可以隐式或者显式地定义内联成员函数。然而，内联函数确实不可导出的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">memfun1</span><span class="params">()</span></span>;<span class="comment">//被导出(exproted)的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">memfun2</span><span class="params">()</span></span>&#123;<span class="comment">//隐式内联不能被导出</span></span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">memfun3</span><span class="params">()</span></span>;<span class="comment">//显式内联不能被导出</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> MyClass&lt;T&gt;::memfun3()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，export关键字不能和inline关键字一起使用：如果用于模板的话，export要位于关键字template前面，譬如下面的程序就是非法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invalid</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">export</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">(T)</span></span>;<span class="comment">//错误：export没有位于template之前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//错误：同时使用了export和inline</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span><span class="comment">//错误：同时使用了export和inline</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-分离模型的限制"><a href="#3-2-分离模型的限制" class="headerlink" title="3.2 分离模型的限制"></a>3.2 分离模型的限制</h4><p>谈到这里，你可能会觉得奇怪：既然导出模板（exported template）可以很好地解决最初的问题，我们为何仍然建议建使用包含模型呢。事实上，export关键字还有其他一方面的影响。</p><p>一方面，几乎没有编译器实现。</p><p>其次，export虽然看起来几乎是完美无缺的，但它实际上还是有一些缺点的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文讲述了C++中组织模板源代码的几种方式——包含模型、显示实例化和分离模型。来源是《C++ templates》。本文中的部分代码可从&lt;a href=&quot;https://pan.baidu.com/s/1dBUlZfFRHU5hJl-RSuf6Nw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;此链接&lt;/a&gt;下载，提取码为4xxq（非书中所带，有错请海涵）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="liuyun594@github.io/categories/C/"/>
    
    
      <category term="C++" scheme="liuyun594@github.io/tags/C/"/>
    
      <category term="template" scheme="liuyun594@github.io/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>miracl库实现ElGamal加解密</title>
    <link href="liuyun594@github.io/2019/11/22/miracl%E5%BA%93%E5%AE%9E%E7%8E%B0ElGamal%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>liuyun594@github.io/2019/11/22/miracl%E5%BA%93%E5%AE%9E%E7%8E%B0ElGamal%E5%8A%A0%E8%A7%A3%E5%AF%86/</id>
    <published>2019-11-22T04:53:55.000Z</published>
    <updated>2020-01-10T05:18:08.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是西电网信院信息安全数学基础的实验题目，要求使用miracl库实现ElGamal加解密。实现代码可在<a href="https://pan.baidu.com/s/1kdi4nBP0RffdbK8SX-daUw" target="_blank" rel="noopener">此链接</a>中下载，提取码为ptwk。</p><a id="more"></a><h3 id="要求实现"><a href="#要求实现" class="headerlink" title="要求实现"></a>要求实现</h3><h4 id="ElGamal的密钥生成过程"><a href="#ElGamal的密钥生成过程" class="headerlink" title="ElGamal的密钥生成过程"></a>ElGamal的密钥生成过程</h4><ol><li><p>生成随机大素数p，求得p的本原根g（本原根也就是模p乘法域的生成元）。</p></li><li><p>随机选择私钥x，1 &lt; x &lt; p-2</p></li><li><p>计算 y = g<sup>x</sup> mod p</p><p>计算得到的公钥为(p, g, y)，对外公布。私钥是x，自己私藏。</p></li></ol><h4 id="ElGamal的加密过程"><a href="#ElGamal的加密过程" class="headerlink" title="ElGamal的加密过程"></a>ElGamal的加密过程</h4><p>假设B要与A进行通信，B所要加密的明文为m，使用ElGamal密码算法，B方执行的加密过程如下：</p><ol><li><p>从A放获得加密所需的公钥(p, g, y)。</p></li><li><p>选择一随机数k，(k, p-1) = 1，1 &lt;= k &lt;= p-2.</p></li><li><p>计算  </p><p>y<sub>1</sub> = g<sup>k</sup> mod p （随机数k被加密）</p><p>再用公钥y，计算：</p><p>y<sub>2</sub> = my<sup>k</sup> mod p (明文被随机数k和公钥y加密)</p><p>密文c = (y<sub>1</sub>, y<sub>2</sub>)。</p></li></ol><h4 id="ElGamal解密过程"><a href="#ElGamal解密过程" class="headerlink" title="ElGamal解密过程"></a>ElGamal解密过程</h4><p>当A接收到密文c = (y<sub>1</sub>, y<sub>2</sub>)之后，解密过程如下：</p><p>使用自己的私钥x计算</p><p>m = (y<sub>1</sub><sup>-x</sup>)y<sub>2</sub> mod p</p><p>获得明文m。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="获取本原根原理"><a href="#获取本原根原理" class="headerlink" title="获取本原根原理"></a>获取本原根原理</h4><p>其实刚开始看到的时候以为实现起来没有什么困难，但当自己开始动手写的时候发现一个问题：本原根g如何求？</p><p>我在网上找了很长时间，没有找到本原根的生成方法，直到找到在<a href="http://www.mathmagic.cn/bbs/simple/?t9356.html" target="_blank" rel="noopener">这个帖子里</a>有人问了同样的问题，@<strong>chinazhaok</strong>这位网友回答了一种方法，并说明在《应用密码学手册》中有相关的算法。</p><p>下面是《应用密码学手册》的算法：</p><p><strong>算法4.80 找循环群的生成元</strong></p><p>​    输入：阶为n的循环群G，n的素因子分解n = p<sup>1</sup>, p<sup>2</sup>, …,  p<sup>k</sup>. </p><p>​    输出：C的一个生成元a。</p><ol><li><p>随机选择一个G中的元素a</p></li><li><p>对 i 从1到k执行如下操作：</p><p>2.1 计算 b &lt;- a<sup>p<sup>i</sup></sup></p><p>2.2 若 b = 1，则转到步骤1.</p></li><li><p>返回 a。</p></li></ol><p>但是问题又来了，大数的素因子分解可本来就是一个难题呀。正当我陷入困境时，课代表的一则通知简直是及时雨点醒了我：</p><p><img src="/images/%E5%AE%9E%E7%8E%B0ElGamal_%E9%80%9A%E7%9F%A5.jpg" alt="课代表的通知"></p><p>要求p = 2*q+1，而且q也是素数！这样的话φ(p) = p-1 = 2*q，而2*q分解不就是2和q吗。所以这个问题也就迎刃而解了。</p><p>实现过程中其他也没什么了，看下面的代码吧，做了尽可能的注释。</p><p>-----------------------------------2020-01-10更新--------------------------------------</p><h4 id="获取强随机数方法"><a href="#获取强随机数方法" class="headerlink" title="获取强随机数方法"></a>获取强随机数方法</h4><p>用纯随机的方法获取强随机数效果并不好，时间太长，老师验收时说可以在一个随机素数周围寻找强随机数，另一种思想是使用miracl库中的nxsafeprime接口，这里选用的老师说的方法。</p><p>-------------------------------------------------------------------------</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exp4.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;miracl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mirdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enc</span><span class="params">(big m, big p, big g, big y, big cs[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function">big <span class="title">dec</span><span class="params">(big cs[<span class="number">2</span>], big p, big x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">miracl *mip = mirsys(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">151</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">big two, one, p, q, g, x, y, m, c, tmp, psubtwo;</span><br><span class="line">big cs[<span class="number">2</span>], ret;</span><br><span class="line"></span><br><span class="line">mip-&gt;IOBASE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//读取文件数据</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;message-file-path&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file open err: can't open file %s !\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fread(msg, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">150</span>, fp) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"file read err: can't read file %s !\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化大数</span></span><br><span class="line">one = mirvar(<span class="number">1</span>);</span><br><span class="line">two = mirvar(<span class="number">2</span>);</span><br><span class="line">p = mirvar(<span class="number">0</span>);</span><br><span class="line">q = mirvar(<span class="number">0</span>);</span><br><span class="line">g = mirvar(<span class="number">2</span>);</span><br><span class="line">x = mirvar(<span class="number">0</span>);</span><br><span class="line">y = mirvar(<span class="number">0</span>);</span><br><span class="line">m = mirvar(<span class="number">0</span>);</span><br><span class="line">c = mirvar(<span class="number">0</span>);</span><br><span class="line">tmp = mirvar(<span class="number">0</span>);</span><br><span class="line">psubtwo = mirvar(<span class="number">0</span>);</span><br><span class="line">irand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">cinstr(m, msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//选取随机素数q和p</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bigbits(<span class="number">499</span>, q);</span><br><span class="line"><span class="keyword">if</span> (isprime(q))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">add(q, two, q);</span><br><span class="line"><span class="keyword">if</span> (!isprime(q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">add(q, q, p);</span><br><span class="line">add(p, one, p);</span><br><span class="line"><span class="keyword">if</span> (isprime(p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*do &#123;</span></span><br><span class="line"><span class="comment">bigbits(500, tmp);</span></span><br><span class="line"><span class="comment">&#125; while (!nxsafeprime(0, 0, tmp, p));</span></span><br><span class="line"><span class="comment">decr(p, 1, q);</span></span><br><span class="line"><span class="comment">sftbit(q, 1, q);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取生成元g</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">powmod(g, two, p, tmp);</span><br><span class="line"><span class="keyword">if</span> (mr_compare(tmp, one) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">powmod(g, q, p, tmp);</span><br><span class="line"><span class="keyword">if</span> (mr_compare(tmp, one) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">add(g, one, g);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (mr_compare(g, p) &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机取x</span></span><br><span class="line">decr(p, <span class="number">2</span>, psubtwo);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">bigrand(psubtwo, x);</span><br><span class="line">&#125; <span class="keyword">while</span> (mr_compare(x, one) &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算y</span></span><br><span class="line">powmod(g, x, p, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出公钥</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"公钥：\n"</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(p, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(g, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"g = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(y, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"y = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出私钥</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"私钥：\n"</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(x, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">enc(m, p, g, y, cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出y1和y2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密文：\n"</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(cs[<span class="number">0</span>], buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"y1 = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(cs[<span class="number">1</span>], buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"y2 = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">ret = dec(cs, p, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出还原的消息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"明文：\n"</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">501</span>);</span><br><span class="line">cotstr(ret, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"message = %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">mirexit();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enc</span><span class="params">(big m, big p, big g, big y, big cs[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">big one, psubone, k, tmp;</span><br><span class="line">one = mirvar(<span class="number">1</span>);</span><br><span class="line">psubone = mirvar(<span class="number">0</span>);</span><br><span class="line">k = mirvar(<span class="number">0</span>);</span><br><span class="line">tmp = mirvar(<span class="number">0</span>);</span><br><span class="line">cs[<span class="number">0</span>] = mirvar(<span class="number">0</span>);</span><br><span class="line">cs[<span class="number">1</span>] = mirvar(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">decr(p, <span class="number">1</span>, psubone);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bigrand(psubone, k);</span><br><span class="line"><span class="keyword">if</span> (mr_compare(k, one) &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">egcd(k, y, tmp);</span><br><span class="line"><span class="keyword">if</span> (mr_compare(tmp, one) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">powmod(g, k, p, cs[<span class="number">0</span>]);</span><br><span class="line">powmod(y, k, p, cs[<span class="number">1</span>]);</span><br><span class="line">multiply(cs[<span class="number">1</span>], m, cs[<span class="number">1</span>]);</span><br><span class="line">powmod(cs[<span class="number">1</span>], one, p, cs[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">mirkill(one);</span><br><span class="line">mirkill(psubone);</span><br><span class="line">mirkill(k);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">big <span class="title">dec</span><span class="params">(big cs[<span class="number">2</span>], big p, big x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">big tmp, one, ret;</span><br><span class="line"></span><br><span class="line">tmp = mirvar(<span class="number">0</span>);</span><br><span class="line">ret = mirvar(<span class="number">0</span>);</span><br><span class="line">one = mirvar(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">powmod(cs[<span class="number">0</span>], x, p, tmp);</span><br><span class="line">xgcd(tmp, p, tmp, tmp, tmp);</span><br><span class="line">fft_mult(cs[<span class="number">1</span>], tmp, tmp);</span><br><span class="line">powmod(tmp, one, p, ret);</span><br><span class="line"></span><br><span class="line">mirkill(tmp);</span><br><span class="line">mirkill(one);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这是西电网信院信息安全数学基础的实验题目，要求使用miracl库实现ElGamal加解密。实现代码可在&lt;a href=&quot;https://pan.baidu.com/s/1kdi4nBP0RffdbK8SX-daUw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;此链接&lt;/a&gt;中下载，提取码为ptwk。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大学作业" scheme="liuyun594@github.io/categories/%E5%A4%A7%E5%AD%A6%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="密码学" scheme="liuyun594@github.io/categories/%E5%A4%A7%E5%AD%A6%E4%BD%9C%E4%B8%9A/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="原创" scheme="liuyun594@github.io/categories/%E5%A4%A7%E5%AD%A6%E4%BD%9C%E4%B8%9A/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="密码学" scheme="liuyun594@github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="ElGamal" scheme="liuyun594@github.io/tags/ElGamal/"/>
    
      <category term="Miracl库" scheme="liuyun594@github.io/tags/Miracl%E5%BA%93/"/>
    
      <category term="原创" scheme="liuyun594@github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Unix环境高级编程：进程环境</title>
    <link href="liuyun594@github.io/2019/11/05/Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>liuyun594@github.io/2019/11/05/Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</id>
    <published>2019-11-05T05:17:01.000Z</published>
    <updated>2019-11-21T05:18:50.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>有8种方式使进程终止，其中5种为征程终止，它们是</p><ol><li>从main返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从其启动例程返回。</li><li>最后一个线程调用pthread_exit</li></ol><p>异常终止有3种，它们是</p><ol start="6"><li>调用abort</li><li>接到一个信号并终止。</li><li>最后一个线程对取消请求做出响应。</li></ol><h4 id="1-exit函数"><a href="#1-exit函数" class="headerlink" title="1. exit函数"></a>1. exit函数</h4><a id="more"></a><p>有三个函数用于正常终止一个程序：_exit和_Exit立即进入内核。exit则先执行一些清理处理（包括调用执行者各终止处理程序，关闭所有标准IO流等），然后进入内核。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><blockquote><p>exit和_Exit是由ISO C说明的，而_eixt则是由POSIX.1说明的。</p></blockquote><p>exit函数总是执行一个标准IO库的清理关闭工作：为所有打开流调用fclose函数。这回造成所有缓冲的输出数据被冲洗。  </p><p>三个exit函数都带有一个整型参数，称之为终止状态。大多数UNIX shell都提供检查进程终止状态的方法。如果(a)若调动这些函数时不带，或(b)main执行了一个无返回值的return语句，或(c)main没有声明返回类型为整型，则该进程的终止状态是未定义的。但是，若main的返回类型为整型，并且main执行到最后一条语句时返回（隐式返回），那么该进程的终止状态是0.  </p><p>main函数赶回一整型值与用该值调用exit是等价的。于是在main函数中exit(0)等价于return(0)。  </p><h4 id="2-atexit函数"><a href="#2-atexit函数" class="headerlink" title="2. atexit函数"></a>2. atexit函数</h4><p>按照ISO C的规定，一个进程可以登记多达32个函数，这些函数将由exit自动调用。我们称这些函数为终止处理程序，并调用atexit函数来登记这些函数。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回非0 */</span></span><br></pre></td></tr></table></figure><p>其中atexit的参数是一个函数地址，当调用此函数时无需向它床底任何参数，也不期望它返回一个值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次，则也会被调用多次。  </p><p>注意，内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显示或隐式地（通过exit）调用_exit或_Exit。进程也可非自愿地由一个信号使其终止。  </p><h3 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h3><p>每个程序都会收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址。全局变量environ为环境指针，指针数组为环境表，其中各指针指向的字符串为环境字符串。   </p><p>按照惯例，环境由name=value这样的字符串组成。  </p><h3 id="存储器分配"><a href="#存储器分配" class="headerlink" title="存储器分配"></a>存储器分配</h3><p>ISO C说明了三个用于存储空间动态分配的函数。</p><ol><li>malloc。分配指定字节数的存储区。此存储区中的初始值不确定。</li><li>calloc。为指定数量具制定长度的对象分配存储空间。该空间中每一位都初始化为0.</li><li>realloc。更改以前分配区的长度（增加或减少）。当增长长度时，可能需将以前分配去的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域的初始值则不确定。  </li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> obj, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br><span class="line"><span class="comment">/* 三个函数返回值：若成功则返回非空指针，若出错则返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>这三个分配函数所返回的指针一定是适当对其的，使其可用于任何数据对象。  </p><p>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池。  </p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>ISO C定义了一个函数getenv，可以用其取环境变量值，但是该标准又称环境的内容是由实现定义的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：指向与name关联的value的指针，若未找到则返回NULL */</span></span><br></pre></td></tr></table></figure><p>注意，此函数返回一个指针，它指向name=value字符串中的value。我们应当使用getenv从环境中取一个指定环境变量的值，而不是直接访问environ。  </p><p>除了取环境变量，有时也需要设置环境变量。我们可能希望改变现有变量。我们可能虚妄改变现有变量的值，或者增加新的环境变量。不幸的是，并不是所有系统都支持这种能力。  </p><table><thead><tr><th>函数</th><th>ISO C</th><th>POSIX.1</th><th>Free BSD 5.2.1</th><th>Linux 2.4.22</th><th>Mac OS X 10.3</th><th>Solaris 9</th></tr></thead><tbody><tr><td>getenv</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>putenv</td><td></td><td>XSI</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>setenv</td><td></td><td>*</td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td>unsetenv</td><td></td><td>*</td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td>clearenv</td><td></td><td></td><td></td><td>*</td><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(cosnt <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">/* 三个函数的返回值：若成功则返回0，若出错则返回非0值 */</span></span><br></pre></td></tr></table></figure><p>这三个函数的操作是：</p><ul><li><p>putenv取形式为name=value的字符串，将其放到黄竞标中。如果name已经存在，则先删除其原来的定义。</p></li><li><p>setenv将name设置为value。如果在环境中name已经存在，那么(a)若rewrite非0，则首先删除其现有的定义；(b)若rewrite为0，则不删除其现有定义（name不设置为新的value，而且也不出错）。</p></li><li><p>unsetenv删除name的定义。即使不存在这种定义也不算出错。  </p></li></ul><h3 id="setjmp和longjmp函数"><a href="#setjmp和longjmp函数" class="headerlink" title="setjmp和longjmp函数"></a>setjmp和longjmp函数</h3><p>在C中，goto语句是不能跨越函数的，而执行这列跳转功能的是函数setjmp和longjmp。这两个函数对于处理发生在深层嵌套函数调用中的出错情况是非常有用的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若直接调用则返回0，若从longjmp调用返回则返回非0值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>setjmp参数env的类型是一个特殊类型jmp_buf。这一数据类型是某种形式的数组，其中存放在调用longjmp时能用来恢复栈状态的所有信息。因为需在另一函数中引用env变量，所以规范的处理方式是将env变量定义为全局变量。  </p><p>longjmp函数第一个参数就是在调用setjmp时所用的env，第二个参数是具有非0值的val，它将成为从setjmp处返回的值。使用第二个参数的原因是对于一个setjmp可以有多个longjmp。   </p><h4 id="1-自动、寄存器和易失变量"><a href="#1-自动、寄存器和易失变量" class="headerlink" title="1. 自动、寄存器和易失变量"></a>1. 自动、寄存器和易失变量</h4><p>在调用setjmp并使用longjmp返回后，自动变量和寄存器变量状态如何？这些变量的值是否能恢复到以前调用setjmp时的值，或是保持为longjmp调用时的值？不幸的是，对此的回答是“看情况”。大多数实现并不回滚这些自动变量和寄存器变量的值，而所有标准则说它们的值是不确定的。如果你有一个自动变量（就是函数内在栈上分配的变量），而又不想使其回滚，则可定义为具有valatile属性（此关键字可使编译器不对变量进行优化），声明为全局或静态变量的值在执行longjmp时保持不变。  </p><h4 id="2-局部变量的潜在问题"><a href="#2-局部变量的潜在问题" class="headerlink" title="2. 局部变量的潜在问题"></a>2. 局部变量的潜在问题</h4><p>为标准IO设置使用setbuf和setvbuf设置缓冲区时，不应使用栈上的数组，因为当分配栈上变量所在函数返回时栈已经重新被新调用的栈帧使用，而标准IO仍使用其缓冲区的存储空间，这就产生了冲突和混乱。为了校正这一问题，应在全局存储空间静态的（如static或exxtern）或者动态地（使用一种alloc函数）为数组databuf分配空间。  </p>  <br>  <br>  <br><h3 id="getrlimit和setrlimit函数"><a href="#getrlimit和setrlimit函数" class="headerlink" title="getrlimit和setrlimit函数"></a>getrlimit和setrlimit函数</h3><p>每个进程都有由自愿限制，其中一些可用getrlimit和setrlimit函数查询和更改。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit* rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> rseource, <span class="keyword">const</span> struct rlimit* rlptr)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功返回0;，若出错返回非0值 */</span></span><br></pre></td></tr></table></figure><p>这两个函数在SUS中定义为XSI扩展。进程的资源限制通常是在系统初始化时由进程0建立的，然后由每个后续进程集成。每种实现都可以用自己的方法对各种限制做出调整。  </p><p>对这两个函数的每一次调用都会制定一个资源以及一个指向下列结构的指针。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;   <span class="comment">/* 软限制：当前的限制值 */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;   <span class="comment">/* 硬限制：rlim_cur的最大值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在更改资源限制时，须遵循下列三条规则：</p><ol><li>任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。</li><li>任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低对普通用户而言是不可逆的。</li><li>只有超级用户进程可以提高其硬限制值。</li></ol><p>常量RLIM_INFINTY制定了一个无限量的限制。</p><p>这两个函数的resource参数区下列值之一。下表显示那些资源限制是由SUS定义并被讨论的四中系统实现支持的。  </p><table><thead><tr><th>限制</th><th>XSI</th><th>FreeBSD 5.2.1</th><th>Linux 2.4.22</th><th>Mac OS X 10.3</th><th>Solaris 9</th></tr></thead><tbody><tr><td>RLIMIT_AS</td><td>*</td><td></td><td>*</td><td></td><td>*</td></tr><tr><td>RLIMIT_CORE</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>RLIMIT_CPU</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>RLIMIT_DATA</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>RLIMIT_FSIZE</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>RLIMIT_LOCKS</td><td></td><td></td><td>*</td><td></td><td></td></tr><tr><td>RLIMIT_MEMLOCK</td><td></td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td>RLIMIT_NOFILE</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>RLIMIT_NPROC</td><td></td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td>RLIMIT_RSS</td><td></td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td>RLIMIT_SBSIZE</td><td></td><td>*</td><td></td><td></td><td></td></tr><tr><td>RLIMIT_STACK</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>RLIMIT_VMEM</td><td></td><td>*</td><td></td><td></td><td>*</td></tr></tbody></table><ul><li><p>RLIMIT_AS：进程可用存储区的最大总长度（字节）。这会影响sbrk函数和mmap函数。</p></li><li><p>RLIMIT_CORE：core文件的最大字节数，若其值为0则组织创建core文件。</p></li><li><p>RLIMIT_CPU：CPU时间的最大值（秒），当超过此软限制时，该向该进程发送SIGXCPU信号。</p></li><li><p>RLIMIT_DATA：数据段的最大字节长度。这是初始化数据、非初始化以及堆的总和</p></li><li><p>RLIMIT_FSIZE：可以创建的文件的最大字节长度。当唱过此软限制时，该向该进程发送SIGXFSZ信号。</p></li><li><p>RLIMIT_LOCKS：一个进程可持有的文件锁的最大数（此数也包括Linux特有的文件租借数）。</p></li><li><p>RLIMIT_MEMLOCK：一个进程使用mlock能够锁定在存储器中的最大字节长度。</p></li><li><p>RLIMIT_NOFILE：每个进程能打开的最大文件数。更改此限制将影响到sysconfig函数在参数_SC_OPEN_MAX中返回的值。</p></li><li><p>RLIMIT_NPROC：每个实际用户ID可拥有的最大子进程数。更改此限制将影响到sysconf函数在参数_SC_CHILD_MAX中返回的值.</p></li><li><p>RLIMIT_RSS：最大驻内存集的自己长度。如果物理存储器供不应求，则内核从进程处收回超过RSS的部分。</p></li><li><p>RLIMIT_SBSIZE：用户在任一给定时刻都可以占用的套接字缓冲区的最大长度（字节）。</p></li><li><p>RLIMIT_STACK：栈的最大字节长度。</p></li><li><p>RLIMIT_VMEM：这是RLIMIT_AS的同义词。</p></li></ul><p>资源限制影响到调用进程并由其子进程继承。这就意味着为了影响一个用户的所有后续进程，需将资源限制的设置构造在shell之中。确实，Bourne shell、GUN Bourne-again shell和Korn shell具有内置的ulimit命令，C shell具有内置的limit命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h3&gt;&lt;p&gt;有8种方式使进程终止，其中5种为征程终止，它们是&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;从main返回&lt;/li&gt;
&lt;li&gt;调用exit&lt;/li&gt;
&lt;li&gt;调用_exit或_Exit&lt;/li&gt;
&lt;li&gt;最后一个线程从其启动例程返回。&lt;/li&gt;
&lt;li&gt;最后一个线程调用pthread_exit&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;异常终止有3种，它们是&lt;/p&gt;&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;调用abort&lt;/li&gt;
&lt;li&gt;接到一个信号并终止。&lt;/li&gt;
&lt;li&gt;最后一个线程对取消请求做出响应。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;1-exit函数&quot;&gt;&lt;a href=&quot;#1-exit函数&quot; class=&quot;headerlink&quot; title=&quot;1. exit函数&quot;&gt;&lt;/a&gt;1. exit函数&lt;/h4&gt;
    
    </summary>
    
    
      <category term="unix环境高级编程" scheme="liuyun594@github.io/categories/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="unix" scheme="liuyun594@github.io/tags/unix/"/>
    
      <category term="笔记" scheme="liuyun594@github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>unix环境高级编程：标准IO库</title>
    <link href="liuyun594@github.io/2019/11/03/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
    <id>liuyun594@github.io/2019/11/03/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A0%87%E5%87%86IO%E5%BA%93/</id>
    <published>2019-11-03T00:05:20.000Z</published>
    <updated>2019-11-21T05:14:21.363Z</updated>
    
    <content type="html"><![CDATA[<p>不仅是Unix，其他很多操作系统都实现了标准IO库。</p><h3 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h3><p>对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准I/O文件流可用于单字节或多字节（“宽”）字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节IO函数（见&lt;wchar.h&gt;），则讲该流的定向设置为宽定向的。若在未定向的流上使用一个单字节IO函数，则将该流的定向设为字节定向的。只有两个函数可以改变流的定向。freopen函数（稍后讨论）清除一个流的定向；fwide函数可用于设置流的定向。  </p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE* fp, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回0 */</span></span><br></pre></td></tr></table></figure><p>根据mode参数的不同值，fwide函数执行不同的工作。</p><ul><li>如若mode参数值为负，fwide将试图使指定的流是字节定向的。</li><li>如若mode参数值为正，fwide将试图使指定的流是宽定向的。</li><li>如若mode参数值为0，fwide将不试图设置流的定向，但返回标示该流定向的值。  </li></ul><p>注意，fwide并不改变已定向流的定向。还应注意的是，fwide无出错返回。试想，如若流是无效的，那么将发生什么呢？我们唯一可依靠的是，调用fwide前先清除errno，从fwide返回时检查errno的值。  </p><p>当打开一个流时，标准IO函数fopen返回一个指向FILE对象的指针。该对象通常是一个结构，它包含了标准IO库为管理该流需要的所有信息，包括用于实际IO的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等。  </p><p>应用程序没有必要检验FILE对象。为了引用一个流，需将FILE指针作为参数传递给每个标准IO函数。其后称指向FILE对象的指针（类型为FILE *）为文件指针。  </p><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>对一个进程预定义了3个流，并且这3个流可以自动地被进程使用，它们是：标准输入、标准输出和标准错误。这些流引用的文件与文件描述符STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO所引用的相同。  </p><p>这3个标准IO流通过预定义文件指针stdin、stdout、stderr加以引用。这3个文件指针定义在头文件&lt;stdio.h&gt;中。  </p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>标准IO库提供缓冲的目的是尽可能减少使用read和write调用的次数。它也对每个IO流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点缩到来的麻烦。遗憾的是，标准IO库最令人疑惑的也是它的缓冲。  </p><p>标准IO提供了以下三种类型的缓冲：  </p><ol><li>全缓冲。在这种情况下，在填满标准IO缓冲区后才进行实际IO操作。对于驻留在磁盘上的文件通常是由标准IO库实施全缓冲的。在一个流上执行一次IO操作时，相关标准IO函数通常使用malloc获得需使用的缓冲区。术语冲洗（flush）说明标准IO缓冲区的写操作。缓冲区可由标准IO例程自动地冲洗（例如。当填满一个缓冲区时），或者可以调用函数fflush冲洗一个流。值得注意的是，在UNIX环境中，flush有两种意思。在标准IO库方面，flush（冲洗）意味着将缓冲区中的内容写到磁盘上（该缓冲区可能只是部分填满的）。在终端驱动程序方面，flush表示丢弃已存储在缓冲区中的数据。</li><li>行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准IO库执行IO操作。这允许我们一次输出一个字符（用标准IO函数fputc）。但只有在写了一行之后才进行实际IO操作。当流设计一个终端时（如标准输入和标准输出），通常使用行缓冲。对于行缓冲有两个限制。第一，因为标准IO库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行IO操作。第二，任何时候只要通过标准IO库要求从(a)一个不带缓冲的流，或者(b)一个行缓冲的流（它从内核请求需要数据）得到输入数据，那么就会冲洗所有行缓冲输出流，它并不要求一定从内核读数据。很明显，从一个不带缓冲的流中输入（即(a)项）需要从内核获得数据。</li><li>不带缓冲。标准IO库不对字符进行缓冲存储。例如，若用标准IO函数fputs写15个字符到不带缓冲的流中，我们就期望这15个字符能立即输出，很可能使用write函数将这些字符写到相关联的打开文件中。标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管他们是否含有一个换行符。</li></ol><p>但是，这并没有告诉我们如果标准输入和标准输出指向交互式设备时，它们是不带缓冲的还是行缓冲的；以及错误是不带缓冲的还是行缓冲的。很多系统默认使用下列类型的缓冲：  </p><ul><li>标准错误是不带缓冲的。</li><li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。</li></ul><p>对于一个给定的流，如果我们并不喜欢这些系统默认，则可调用下列两个函数中的一个更改缓冲类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回非0 */</span></span><br></pre></td></tr></table></figure><p>这些函数一定要在流已经被打开后调用，而且也应在对该流执行任何一个其他操作之前调用。  </p><p>使用setvbuf，我们可以精确地说明所需的缓冲类型。这是用mode参数实现的：  </p><p>_IOFBF       全缓冲  </p><p>_IOLBF       行缓冲  </p><p>_IONBF      不缓冲  </p><p>如果指定一个不带缓冲的流，则忽略buf 和size参数。如果指定全缓冲或行缓冲，则buf和size可选择地制定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准IO库将自动地为该流分配适当长度的缓冲区。适当长度指的是由敞亮BUFSIZ所指定的值。  </p><blockquote><p>某些C函数库实现使用stat结构中的成员st_blksize所指定的值决定最佳IO缓冲区长度。GUN C函数库就使用这种方法。</p></blockquote><p>任何时候，我们都可以前置冲洗一个流。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回值EOF */</span></span><br></pre></td></tr></table></figure><p>此函数使该流所有未写的数据都被传送至内核。作为一种特殊情形，如果fp是NULL，则此函数将导致所有输出流被冲洗。  </p><h3 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h3><p>下列3个函数打开一个标准流。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数的返回值：若成功，返回文件指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure><p>这3个函数的区别如下：  </p><ol><li>fopen函数打开路径名为pathname的一个指定文件。</li><li>freopen函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若该流已经定向，则使用freopen清除该定向。此函数一般用于将一个制定的文件打开为一个预定义的流：标准输入、标准输出和标准错误。</li><li>fdopen函数取一个已有的文件描述符（我们可能从open、dup、dup2、fcntl、pipe、sockesocketpair或accept函数得到此文件描述符），并使一个标准的IO流与该描述符相结合。此函数常用于由常见管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准IO函数打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准IO流与该描述符相结合。  </li></ol><blockquote><p>fopen接freopen是ISO C的所属部分。而ISO C并不涉及文件描述符，所以仅有POSIX.1具有fdopen。</p></blockquote><p>type参数制定对该IO流的读写方式，ISO C规定type参数可以有15种不同的值。  </p><table><thead><tr><th>type</th><th>说明</th><th>open(2)标志</th></tr></thead><tbody><tr><td>r或rb</td><td>为读而打开</td><td>O_RDONY</td></tr><tr><td>w或wb</td><td>把文件截断至0长，或为写而创建</td><td>O_WRONLY|O_CREAT|O_TRUNC</td></tr><tr><td>a或ab</td><td>追加；为在文件尾写而打开，或为写而创建</td><td>O_WRONLY|O_APPEND|O_CREAT</td></tr><tr><td>r+或r+b或rb+</td><td>为读和写而打开</td><td>O_RDWR</td></tr><tr><td>w+或w+b或wb+</td><td>把文件截至0长，或为读和写而打开</td><td>O_RDWR|O_CREAT|O_TRUNC</td></tr><tr><td>a+或a+b或ab+</td><td>为在文件尾读和写打开或创建</td><td>O_RDWR|O_CREAT|O_APPEND</td></tr></tbody></table><p>fdopen为写而打开并不截断该文件。另外，标准IO追加写方式也不能用于创建该文件。  </p><p>当以读和写类型打开一个文件时(type中带+号)，具有下列限制。</p><ul><li>如果中间没有fflush、fseek、fsetpos或rewind，则在输出后面不能直接跟随输入。</li><li>如果中间没有fseek、fsetpos或frewind，或者一个输入操作没有到达文件尾端，则在输入操作后不能直接跟随输出。</li></ul><table><thead><tr><th>限制</th><th>r</th><th>w</th><th>a</th><th>r+</th><th>w+</th><th>a+</th></tr></thead><tbody><tr><td>文件必须存在</td><td>*</td><td></td><td></td><td>*</td><td></td><td></td></tr><tr><td>放弃文件以前的内容</td><td></td><td>*</td><td></td><td></td><td>*</td><td></td></tr><tr><td>流可以读</td><td>*</td><td></td><td></td><td>*</td><td>*</td><td>*</td></tr><tr><td>流可以写</td><td></td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>流只可在尾端处写</td><td></td><td></td><td>*</td><td></td><td></td><td>*</td></tr></tbody></table><p>注意，在指定w或a类型创建一个新文件时，我们无法寿命该文件的访问权限位。POSIX.1要求使用如下的权限位集来创建文件：  </p><p>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH  </p><p>调用fclose关闭一个打开的流。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回EOF */</span></span><br></pre></td></tr></table></figure><p>在该文件被关闭之前，冲洗缓冲区中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准IO库已经为该流自动分配了一个缓冲区，则释放该缓冲器。  </p><p>当一个进程正常终止时（直接调用exit函数，或从main函数返回），则所有未写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭。  </p><h3 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h3><p>一旦打开了流，则可在3种不同类型的非格式化IO中进行选择，对其进行读、写操作。  </p><ol><li>每次一个字符的IO。一次读或写一个字符，如果流是带缓冲的，则标准IO函数处理所有缓冲。  </li><li>每次一行的IO。如果想要一次读或写一行，则使用fgets和fputs。每行都以一个换行符终止。当调用fgets时，应说明能处理的最大行长。  </li><li>直接IO，fread和fwrite函数支持这种IO。每次IO操作读或写某种数量的对象，每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。   </li></ol><h4 id="1-输入函数"><a href="#1-输入函数" class="headerlink" title="1. 输入函数"></a>1. 输入函数</h4><p>以下3个函数可用以一次读一个字符。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回下一个字符；若已达文件尾端或出错，返回EOF */</span></span><br></pre></td></tr></table></figure><p>函数getchar等同于getc(stdin)。前两个函数的区别是，getc可被实现为宏，而fgetc不能实现为宏。这意味着以下几点：   </p><ol><li>getc的参数不应当是具有副作用的表达式，因为它可能会被计算多次。</li><li>因为fgetc一定是个函数，所以可以得到其地址。这就允许将fgetc的地址作为一个参数传送给另一个函数。</li><li>调用fgetc所需的时间可能比调用getc要长，因为调用函数所需的时间通常长于宏。</li></ol><p>注意，不管是出错还是达到文件尾端，这3个函数都是返回同样的值。为了区分这两种情况，必须调用ferror或feof。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若条件为真，返回0（真）；否则，返回非0（假） */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>在大多数实现中，为每个流在FILE对象中维护了两个标志。  </p><ul><li>出错标志；</li><li>文件结束标志。</li></ul><p>调用clearerr可以清除这两个标志。  </p><p>从流中读取数据以后，可以调用ungetc将字符再压送回流中。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回c；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure><p>压送回到流中的字符以后可又可以从流中读出，但读出字符的顺序与压送顺序相反。  </p><p>回送的私服，不一定必须是上一次读的字符。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再读则返回EOF。原因是一次成功的ungetc调用会清除该流的文件结束标志。   </p><h4 id="2-输出函数"><a href="#2-输出函数" class="headerlink" title="2. 输出函数"></a>2. 输出函数</h4><p>对应于上面所述的每个输入函数都有一个输出函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回c；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure><p>与输入函数一样，putchar(c)等同于putc(c, stdout)，putc可被实现为宏，而fputc不能实现为宏。  </p><h3 id="每次一行IO"><a href="#每次一行IO" class="headerlink" title="每次一行IO"></a>每次一行IO</h3><p>下面两个函数提供每次输入一行的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* buf)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回buf；若已到达文件尾端或出错，返回NULL */</span></span><br></pre></td></tr></table></figure><p>这两个函数都制定了缓冲区地址，读入的行将送入其中。fgets从标准输入读，而fgets则从制定的流读。  </p><p>对于fgets，必须制定缓冲的长度n。此函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。该缓冲区以null字节结尾。如若改行包括最后一个换行符的字符数超过n-1，则fgets只会返回一个不完整的行，但是，缓冲区总是以null结尾。对fgets的下一次调用会继续执行。  </p><p>gets是一个不推荐使用的函数。其问题是调用者在使用gets时不能制定缓冲区的长度。gets与fgets的另一个区别是，gets并不将换行符存入缓冲区中。  </p><p>fputs和puts提供每次输出一行的功能。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br></pre></td></tr></table></figure><p>函数fputs将一个以null字节终止的字符写到指定的流，尾端的终止符null不写出。注意，这不一定是每次输出一行，因为字符串不需要换行符作为最后一个非null字节。通常，在null字节之前是一个换行符，但并不要求总是如此。  </p><p>puts将一个以null字节终止的字符串写到标准输出，终止字符不写出。但是puts随后又将一个换行符写到标准输出。  </p><p>puts并不像它所对应的gets那样不安全。但是我们还是应避免使用它，以免需要记住它在最后是否添加了一个换行符。如果总是使用fgets和fputs，那么就会数值在每行终止处我们必须自己处理换行符。  </p><h3 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="comment">/* 两个函数的返回值：读或写的对象数 */</span></span><br></pre></td></tr></table></figure><p>这些函数由以下两个常见的用法。</p><ol><li>读或写一个二进制数组。</li><li>读或写一个结构。</li></ol><p>fread返回读或写的对象数。对于读，如果出错或到达文件尾端，则此数字可以少于nobj。在这种情况，应调用ferror或feof以判断究竟是哪一种情况。对于写，如果返回值小于所要求的nobj，则出错。  </p><p>使用二进制IO的基本问题是，它只能用于读在同一系统上已写的数据。常常有这种情景，在一个系统上写数据，要在另一个系统上进行处理，在这种环境下，这两个函数可能就不能正常工作，其原因是是：  </p><ol><li>在一个结构中，统一成员的偏移量可能随编译程序和系统的不同而不同（由于不同的对齐要求）。</li><li>用来存储多字节整数和浮点数的二进制格式在不同系统结构件也可能不同。</li></ol><h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><p>有3中方法定位标准IO流</p><ol><li>ftell和fseek函数。这两个函数自V7以来就存在了，但是他们都假定文件的位置可以存放在长整形中。</li><li>ftello和fseeko函数。SUS引入了这两个函数，使文件偏移量可以不必一定使用长整形。他们使用off_t数据类型代替了长整形。</li><li>fgetpos和fsetpos函数。这两个函数是由ISO C引入的。他们使用一个抽象数据类型fpos_t记录文件位置。这种数据类型可以根据需要定义为一个足够大的数，用以记录文件位置。</li></ol><p>需要移植到非UNIX系统上运行的应用程序应当使用fgetpos和fsetpos。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置指示；若出错，返回-1L */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位的。ftell用于二进制文件时，其返回值就是这种字节位置。为了用fseek定位一个二进制文件，必须制定一个字节offset，以及解释这种偏移量的方式whence的值与lseek函数的相同：SEEK_SET表示从文件的其实位置开始，SEEK_CUR表示从当前位置开始，SEEK_END表示从文件尾端开始。ISO C并不要求一个实现对二进制文件支持SEEK_END规格说明，其原因是某些系统要求二进制文件的长度是某个幻数的整数倍，结尾非实际内容部分则填充为0.但是在Unix系统中，对于二进制文件，则是支持SEEK_END的。  </p><p>对于文本文件，他们的文件当前位置可能不以简单的字节偏移量来度量。这主要也是在unix系统中，他们可能以不同的格式放文本文件。为了定位一个文本文件,whence一定要是SEEK_SET，而且offset只能由两种值：0（后退到文件的起始位置），或是对该文件的ftell所返回的值。使用rewind函数也可以将一个流设置到文件的起始位置。  </p><p>除了偏移量的类型是off_t而非long以外，ftello函数与ftell相同，fseeko函数与fseek相同。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> ftello(FILE* fp);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置；若出错，返回(off_t)-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE* fp, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">/* fanhuizhi：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure><p>可将off_t类型定义为长于32位。  </p><p>fgetpos和fsetpos两个函数是ISO C标准引入。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure><p>fgetpos将文件位置指示器的当前值存入由pos指向的对象中。在以后调用fsetpos时，可以使用此值将流重新定位至该位置。  </p><h3 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h3><h4 id="1-格式化输出"><a href="#1-格式化输出" class="headerlink" title="1. 格式化输出"></a>1. 格式化输出</h4><p>格式化输出是由5个printf函数来处理的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回输出字符数；若输出出错，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回存入数组的字符数；若编码出错，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> , <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 */</span></span><br></pre></td></tr></table></figure><p>printf将格式化数据写到标准输出。fprintf写至指定的流，dprintf写至制定的文件描述符，sprintf将格式化的字符送入数组buf中。sprintf在数组的尾端自动加一个null字节，但该字符不包括在返回值中。  </p><p>下列5种printf族的辩题类似于上面的5种，但是可变参数表（…）替换成了arg。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vdprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回输出字符数；若输出出错，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回存入数组的字符数；若编码出错，返回负值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> , <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 */</span></span><br></pre></td></tr></table></figure><h4 id="2-格式化输入"><a href="#2-格式化输入" class="headerlink" title="2. 格式化输入"></a>2. 格式化输入</h4><p>执行格式化输入处理的是3个scanf函数。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>× <span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：赋值的输入项数；若输入出错或在任一转换前已到达文件尾端，返回EOF */</span></span><br></pre></td></tr></table></figure><p>scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量。在格式之后的各参数包含了变量的地址，用转换结果对这些变量赋值。  </p><p>与printf族相同，scanf族也是用由&lt;stdarg.h&gt;说明的可变长度参数表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>× <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfscanf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：赋值的输入项数；若输入出错或在任一转换前已到达文件尾端，返回EOF */</span></span><br></pre></td></tr></table></figure><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>如前所述，在Unix中，标准IO库最终要调用笔记1中说明的IO例程。每个标准IO流都有一个与其相关联的文件描述符，可对一个流调用fileno函数获得其描述符。</p><blockquote><p>注意，fileno不是ISO C标准部分，而是POSIX.1支持的扩展。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：与该流相关联的文件描述符 */</span></span><br></pre></td></tr></table></figure><p>如果要调用dup或fcntl等函数，则需要此函数。  </p><h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><p>ISO C标准IO库提供了两个函数以帮助创建临时文件。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span>* ptr)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：指向唯一路径名的指针 */</span></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回文件指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure><p>tmpname函数生成一个与现有文件名不同的一个有效路径名字字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是TMP_MAX。TMP_MAX定义在&lt;stdio.h&gt;中。  </p><p>若ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用tmpnam时，会重写该静态区（这意味着，如果我们调用此函数多次，而且想保存路径名，则我们应当保存该路径名的副本，而不知指针的副本）。ptr不是NULL，则认为它应该是指向长度至少是L_tmpnam个字符的数组（常量L_tmpnam定义在头文件&lt;stdio.h&gt;中）。所产生的路径名存放在该数组中。ptr作为函数值返回。  </p><p>tmpfile创建一个临时位二进制文件（类型wb+），在关闭该文件或程序结束时将自动删除这种文件。注意，Unix对二进制文件不进行特殊区分。  </p><p>tmpfile函数进程使用的标准Unix技术是先调用tmpnam产生一个唯一的路径名，然后，用该路径名创建一个文件，并立即unlink它。对一个文件解除链接并不删除其内容，关闭该文件时才删除其内容。而关闭文件可以使显式的，也可以在程序终止时自动进行。  </p><p>SUS为处理临时文件定义了另外两个函数：mkdtemp和mkstemp，它们是XSI的扩展部分。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指向目录名的指针；若出错，返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回文件描述符；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>mkdtemp函数创建了一个目录，该目录有一个唯一的名字；mkstemp函数创建了一个文件，该文件由一个唯一的名字。名字是通过template字符串进行选择的。这个字符串是后6位设置为XXXXXX的路径名。函数将这些占位符替换成不同的字符串来构建成一个唯一的路径名。如果成功的话，这两个函数将修改template字符串反应临时文件的名字。  </p><p>由mkdtemp函数创建的目录使用下列访问权限集：S_IRUSR|S_IWUSR|S_IXUSR。注意，调用进程的文件模式创建屏蔽字可以进一步限制这些权限。如果目录创建成功，mkdtemp返回新目录的名字。  </p><p>mkstemp函数以唯一的名字创建一个普通文件并且打开该文件，该函数返回的文件名描述符以读写方式打开。由mkstemp创建的文件使用访问权限位S_IRUSR|S_IWUSR。  </p><p>与tmpfile不同，mkstemp创建的临时文件并不会自动删除。如果希望从文件系统命名空间中删除该文件，必须自己对它解除链接。  </p><p>  `</p><h3 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h3><p>在SUSv4中支持了内存流。这就是标准IO流，随人仍使用FILE指针进行访问，但其实并没有底层文件。所有的IO都是通过在缓冲区与驻村之间来回传送字节来完成的。我们将看到，即便这些流看起来像文件流，它们的某些特征使其更适用于字符串操作。  </p><p>有3个函数可用于内存流的创建，第一个是fmemopen函数。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回流指针；若错误，返回NULL */</span></span><br></pre></td></tr></table></figure><p>fmemopen函数允许调用者提供缓冲区用于内存流：buf参数指向内存区的开始位置，size参数指定了缓冲区大小的字节数。如果buf参数为空，fmemopen函数分配size字节数的缓冲区。在这种情况下，当流关闭时缓冲区会被释放。  </p><p>用于创建内存流的其他两个函数分别是open_memstream和open_wmemstream。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span>** bufp, <span class="keyword">size_t</span>* sizep)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">open_wmemstream</span><span class="params">(<span class="keyword">wchar_t</span> **bufp, <span class="keyword">size_t</span>* sizep)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回流指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure><p>open_memstream函数创建的流是面向字节的。open_wmemstream函数创建的流是面向款字节的。这两个函数与fmemopen函数的不同在于。  </p><ul><li>创建的流只能写打开；</li><li>不能制定自己的缓冲区，但可以分别通过bufp和sizep参数访问缓冲区地址和大小；</li><li>关闭流后需要自行释放缓冲区；</li><li>对流添加字节会增加缓冲区大小。</li></ul><p>但是在缓冲区地址和大小的使用上必须遵循一些原则。第一，缓冲区地址和长度只有在调用fclose或fflush后才有效；第二，这些值只有在下一次流写入或调用fclose前才有效。因为缓冲区增长，可能需要重新分配。如果出现这种情况，我们会发现缓冲区的内存地址值在下一次调用fclose或fflush时会改变。  </p><p>因为避免了缓冲区溢出，内存刘非常适合用于创建字符串。因为内存流只访问驻村，不访问磁盘上的文件，所以对于把标准IO流作为参数用于临时文件的函数来说，会有很大的性能提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不仅是Unix，其他很多操作系统都实现了标准IO库。&lt;/p&gt;&lt;h3 id=&quot;流和FILE对象&quot;&gt;&lt;a href=&quot;#流和FILE对象&quot; class=&quot;headerlink&quot; title=&quot;流和FILE对象&quot;&gt;&lt;/a&gt;流和FILE对象&lt;/h3&gt;&lt;p&gt;对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准I/O文件流可用于单字节或多字节（“宽”）字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节IO函数（见&amp;lt;wchar.h&amp;gt;），则讲该流的定向设置为宽定向的。若在未定向的流上使用一个单字节IO函数，则将该流的定向设为字节定向的。只有两个函数可以改变流的定向。freopen函数（稍后讨论）清除一个流的定向；fwide函数可用于设置流的定向。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="unix环境高级编程" scheme="liuyun594@github.io/categories/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="unix" scheme="liuyun594@github.io/tags/unix/"/>
    
      <category term="笔记" scheme="liuyun594@github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="标准IO" scheme="liuyun594@github.io/tags/%E6%A0%87%E5%87%86IO/"/>
    
  </entry>
  
  <entry>
    <title>unix环境高级编程：文件和目录</title>
    <link href="liuyun594@github.io/2019/10/29/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>liuyun594@github.io/2019/10/29/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</id>
    <published>2019-10-29T00:02:44.000Z</published>
    <updated>2019-11-21T05:15:40.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, struct stat* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 所有四个函数的返回值：若成功：返回0；若出错：返回-1 */</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>  一旦给出pathname，    </p><ul><li>stat函数将返回与此命名文件有关的信息结构；  </li></ul><ul><li>fstat函数获得已在描述符fd上打开文件的相关信息。</li></ul><ul><li>lstat函数类似于stat，但是当命名文件是一个符号链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息。</li></ul><ul><li>fstatat函数为一个相对于当前目录（由fd指定）的路径名返回文件信息。flag参数控制着是否跟随着一个符号链接。当AT_SYMLINK_NOFOLLOW标志被设置时，fstatat不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所指向的实际文件的信息。如果fd参数的值是AT_FDCWD，并且pathname参数是一个相对路径名，fstatat会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径，fd参数就会被忽略。在这两种情况下，根据flag的取值，fstatat的作用就跟stat或lstat一样。  </li></ul><p>stat结构：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">mode_t</span>st_mode;<span class="comment">/*file type &amp; mode (permissions)*/</span></span><br><span class="line">    <span class="keyword">ino_t</span>st_ino;<span class="comment">/*i-node number (serial number)*/</span></span><br><span class="line">    <span class="keyword">dev_t</span>st_dev;<span class="comment">/*device number (file system)*/</span></span><br><span class="line">    <span class="keyword">dev_t</span>st_rdev;<span class="comment">/*device number for special files*/</span></span><br><span class="line">    <span class="keyword">nlink_t</span>st_nlink;<span class="comment">/*number of links*/</span></span><br><span class="line">    <span class="keyword">uid_t</span>st_uid;<span class="comment">/*user id of owner*/</span></span><br><span class="line">    <span class="keyword">gid_t</span>st_gid;<span class="comment">/*group id of owner*/</span></span><br><span class="line">    <span class="keyword">off_t</span>st_size;<span class="comment">/*size in bytes, for regular files*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">st_atime</span>;</span><span class="comment">/*time of last access*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">st_mtime</span>;</span><span class="comment">/*time of last amodification*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">st_ctime</span>;</span><span class="comment">/*time of last file stats change*/</span></span><br><span class="line">    <span class="keyword">blsize_t</span>st_blsize;<span class="comment">/*best I/O block size*/</span></span><br><span class="line">    <span class="keyword">blcnt_t</span>st_blocks;<span class="comment">/*number of disk blocks allocated*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>POSIX.1 未要求st_rdev、st_blsize和st_blocks 字段。SUS XSI扩展定义了这些字段。</p></blockquote><p>timespec结构类型按照秒和纳秒定义了时间，至少包括下面两个字段。</p><ul><li>time_t    tv_sec;</li><li>long        tv_nsec;</li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ol><li><p>普通文件(regular file)。这是最常用的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据，对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。</p></li><li><p>目录文件(directory file)。这种文件包含了其他文件的名字以及指向与这些有关信息的指针。对一个目录文件具有读权限的任意进程都可以读该目录的内容，但只有内核可以直接写目录文件。进程必须使用系统调用才能更改目录。</p></li><li><p>块特殊文件(block special file)。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。</p></li><li><p>字符特殊文件(character special file)。这种类型的文件提供对是被不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</p></li><li><p>FIFO。这种类型的文件用于进程间通信，又是也称为命名管道(named pipe)。</p></li><li><p>套接字(socket)。这种类型的文件用于进程间的网络通信。套接字特可用于在一台宿主机上进程之间的非网络通信。</p></li><li><p>符号链接(symbolic link)。这种类型的文件指向另一个文件。</p></li></ol><p>文件类型信息包含在stat结构的st_mode成员中。可以用下表中的宏确定文件类型。这些宏的参数都是stat结构中的st_mode成员。</p><table><thead><tr><th>宏</th><th>文件类型</th></tr></thead><tbody><tr><td>S_ISREG()</td><td>普通文件</td></tr><tr><td>S_ISDIR()</td><td>目录文件</td></tr><tr><td>S_ISCHR()</td><td>字符特殊文件</td></tr><tr><td>S_ISBLK()</td><td>块特殊文件</td></tr><tr><td>S_ISFIFO()</td><td>管道或FIFO</td></tr><tr><td>S_ISLNK()</td><td>符号链接</td></tr><tr><td>S_ISSICK()</td><td>套接字</td></tr></tbody></table><p>POSIX.1 允许实现将进程间通信(IPC)对象（如详细队列和信号量等）说明为文件。下表中的宏可用来从stat结构中确定IPC对象的类型。这些宏与表中的不同，他们的参数并非st_mode，而是指向stat结构的指针。    </p><table><thead><tr><th>宏</th><th>对象的类型</th></tr></thead><tbody><tr><td>S_TYPEISMQ()</td><td>消息队列</td></tr><tr><td>S_TYPEISSEM()</td><td>信号量</td></tr><tr><td>S_TYPEISSHM()</td><td>共享存储对象</td></tr></tbody></table><h3 id="设置用户ID和组ID"><a href="#设置用户ID和组ID" class="headerlink" title="设置用户ID和组ID"></a>设置用户ID和组ID</h3><p>实际用户ID、实际组ID  =&gt; 我们实际上是谁；  </p><p>有效用户ID、有效组ID、附属组ID  =&gt; 用于文件访问权限检查；  </p><p>保存的设置用户ID、保存的设置组ID =&gt; 由exec函数保存。  </p><ul><li>实际用户和实际组ID标示我们究竟是谁。这两个字段在登陆时取自空灵文件中的登陆项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它他们。  </li><li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li><li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。  </li></ul><h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><p>st_mode值也包含了对文件的访问权限位。当提及文件时，指的是前面所提到的任何类型的文件。所有文件类型（目录、字符特殊文件等）都有访问权限（accsee permission）。  </p><p>每个文件有9个访问权限位，可将他们分成3类。见下表（取自&lt;sys/stat.h&gt;）。  </p><table><thead><tr><th>st_mode屏蔽</th><th>含义</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>用户读</td></tr><tr><td>S_IWUSR</td><td>用户写</td></tr><tr><td>S_IXUSR</td><td>用户执行</td></tr><tr><td></td><td></td></tr><tr><td>S_IRGRP</td><td>组读</td></tr><tr><td>S_IWGRP</td><td>组写</td></tr><tr><td>S_IXGRP</td><td>组执行</td></tr><tr><td></td><td></td></tr><tr><td>S_IROTH</td><td>其他读</td></tr><tr><td>S_IWOTH</td><td>其他写</td></tr><tr><td>S_XOTH</td><td>其他执行</td></tr></tbody></table><p>​    </p><p>在上表前三行中，术语用户指的是文件所有者(owner)。chmod命令用于修改这9个权限位。该命令允许我们用u表示用户（所有者），用g表示组，用o表示其他。    </p><p>上表中的3类访问权限（即读、写和执行）以各种方式由不同的函数使用。其汇总如下：  </p><ul><li>第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因。  </li><li>对一个文件的读权限决定了我们是否能够打开现有文件进行读操作。这与open函数的O_RDONLY和O_RDWR标志相关。</li><li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作。这与open函数的O_WDONLY和O_RDWR标志相关。</li><li>为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限。</li><li>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。</li><li>为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身不需要有读、写权限。</li><li>如果用7个exec函数中的任何一个执行某个文件，都必须对该文件具有执行权限。该文件还必须是一个普通文件。</li></ul><h3 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h3><p>新文件的用户ID设置文进程的有效用户ID。关于组ID, POSIX.1允许实现选择下列之一作为新文件的组ID。  </p><ol><li>新文件的组ID可以是进程的有效组ID。</li><li>新文件的组ID可以是它所在目录的组ID。</li></ol><p>使用POSIX.1所允许的第二个选项（继承目录的组ID）使得在某个目录下创建的文件和目录都具有该目录的组ID。于是文件和目录的所有权从该店向下传递。  </p><h3 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h3><p>access和faccessat函数是按实际用户ID和实际组ID进行权限测试的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/*两个函数的返回值：若成功，返回0；若出错，返回-1*/</span></span><br></pre></td></tr></table></figure><p>其中，如果测试文件是否已经存在，mode就为F_OK；否则mode就是下表中所列常量的按位或。</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>R_OK</td><td>测试读权限</td></tr><tr><td>W_OK</td><td>测试写权限</td></tr><tr><td>X_OK</td><td>测试执行权限</td></tr></tbody></table><p>faccessat函数与access在下面两个情况下是相同的：一种是pathname参数位绝对路径，另一种是fd参数取值为AT_FDCWD而pathname参数为相对路径。负责，faccessat计算相对于打开目录（由fd参数指向）的pathname。  </p><p>flag参数可以用于改变facessat的行为，如果flag设置为AT_EACESS，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。</p><h3 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h3><p>umask函数为进程设置文件模式创建屏蔽字，并返回之前的值。（没有出错返回）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sy/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</span><br><span class="line"><span class="comment">/* 返回值：之前的文件模式创建屏蔽字 */</span></span><br></pre></td></tr></table></figure><p>其中参数cmask是由S_IRUSER、S_IWUSR等9个常量中的若干个按位“或”构成的。  </p><h3 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h3><p>chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/*3个函数返回值：若成功，返回0；若出错，返回-1*/</span></span><br></pre></td></tr></table></figure><p>为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有娼妓用户权限。  </p><p>参数mode使下表常量的按位或。</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>S_ISUID</td><td>执行时设置用户ID</td></tr><tr><td>S_ISGID</td><td>执行时设置组ID</td></tr><tr><td>S_ISVTX</td><td>保存正文（粘着位）</td></tr><tr><td>S_IRXU</td><td>用户（所有者）读、写、执行</td></tr><tr><td>S_IRUSR</td><td>用户（所有者）读</td></tr><tr><td>S_IWUSR</td><td>用户（所有者）写</td></tr><tr><td>S_IXUSR</td><td>用户（所有者）执行</td></tr><tr><td>S_IRWXG</td><td>组读、写、执行</td></tr><tr><td>S_IRGRP</td><td>组读</td></tr><tr><td>S_IWGRP</td><td>组写</td></tr><tr><td>S_IXGRP</td><td>组执行</td></tr><tr><td>S_IRWXO</td><td>其他读、写、执行</td></tr><tr><td>S_IROTH</td><td>其他读</td></tr><tr><td>S_IWOTH</td><td>其他写</td></tr><tr><td>S_IXOTH</td><td>其他执行</td></tr></tbody></table><h3 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h3><p>粘着位（stick bit）在早期表示程序退出时其正文仍保存在交换区，直至系统自举，后来的unix系统称其为保存正文位(saved-text bit)。  </p><p>现今的系统扩展了粘着位的使用范围，SUS允许针对目录设置粘着位。如果对一个目录设置了粘着位，只有对该目录具有写权限的用户且满足下列条件之一，才能删除或重命名该目录下的文件：  </p><ul><li>拥有此文件</li><li>拥有此目录</li><li>是超级用户</li></ul><h3 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数chown、fchown、fchownat和lchown</h3><p>用于更改文件的用户ID和组ID，如果两个参数owner或group中的任意一个是-1，则对应ID不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> git)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="comment">/* 4个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>除了所引用的文件是符号链接外，这4个函数的操作类似。在符号链接情况下，lchown和fchownat（设置了AT_SYMLINK_NOFOLLOW标志）更改符号链接本身的所有者，而不是该符号链接所指向的文件的所有者。</p><h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>stat结构成员st_size表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。  </p><blockquote><p>FreeBSD 8.0、Mac OS X 10.6.8和Solaris 10对管道也定义了文件长度，它标志可从该管道中读到的字节数。</p></blockquote><p>对于普通文件，其文件长度可以是0，在开始读这种文件时，将得到文件结束(end-of-file)指示。对于目录，文件长度通常是一个数（如16或512）的整数倍。</p><p>对于符号链接，文件长度是在文件名中的实际字节数。</p><p>现今，大多数现代的UNXI系统提供字段st_blksize和st_blocks。其中，第一个是对文件I/O较合适的块长度，第二个是所分配的实际512字节块块数。当我们将st_blksize用于读操作时（即st_blksize作为缓冲区长度），读一个文件所需的时间量最少。为了提高效率，标准I/O库也试图一次读、写st_blksize个字节。</p><h4 id="文件中的空洞"><a href="#文件中的空洞" class="headerlink" title="文件中的空洞"></a>文件中的空洞</h4><p>空洞是由所设置的偏移量超过文件尾端，并写入了某些数据后造成的。</p><p>对于没有写过的字节位置，read函数独到的字节是0。</p><p>如果使用实用程序复制这个文件，那么所有这些空洞都会被填满，其中所有实际数据字节皆填写为0.</p><h3 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h3><p>有时候我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例，在打开文件时使用O_TRUNC标志就可以做到这一点。为了阶段文件可以调用函数truncate 和ftruncate。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">/*两个函数的返回值：若成功，返回0；若出错，返回-1*/</span></span><br></pre></td></tr></table></figure><p>这两个函数将一个现有文件长度截为length。如果该文件以前的长度大于length，则超过length以外的数据就不能再访问。如果以前的长度小于length，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0（也就是可能在文件中创建了一个空洞）。</p><h3 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数link、linkat、unlink、unlinkat和remove</h3><p>创建一个指向现有文件的链接（硬链接）的方法时使用link函数或linkat函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>这两个函数创建一个新目录项newpath，它引用现有文件existingpath。如果newpath已经存在，则返回出错。只创建newpath中的最后一个分量，路径中的其他部分应当已经存在。  </p><p>创建新目录项和增加链接计数应当是一个原子操作。  </p><p>为了删除一个现有的目录项，可以调用unlink函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>这两个函数删除目录项，并将由pathname所引用文件的链接计数减1。    </p><p>只有当链接计数到达0时，文件才能删除。另一个条件也会阻止删除文件的内容——只要有进程打开了该文件，其内容也不能删除。<strong>关闭一个文件时，内核首先检查打开该文件的进程个数；如果这个计数达到0，内核再去检查其链接计数；如果也是0，那么就删除该文件的内容</strong>。</p><p>flag参数给出了一种方法，是进程可以改变unlinkat函数的默认行为。当AT_REMVOEDIR标志被设置时，unlinkat函数可以类似于rmdir一样删除目录。如果这个标志被清除，unlinkat与unlink执行同样的操作。  </p><p>  我们也可以用 remove 函数接触对一个文件或目录的链接。对于文件，remove的功能与unlink相同。对于目录，remove的功能与rmdir相同。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure><h3 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h3><p>文件或者目录能用rename函数或者renameat函数进行重命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>  若newname已经存在：oldname是文件时，newname必须是文件，会将newname删掉并将oldname重命名为newname；oldname是目录时newname必须是目录且是空目录（其下只有.和..），会将newname删掉并将oldname重命名为newname。</p><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>符号链接是对一个文件的间接指针，它与硬链接不同，硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制。</p><ul><li>硬链接通常要求链接和文件位于同一文件系统。</li><li>只有超级用户才能创建指向目录的硬链接（在第层文件系统支持的情况下）。</li></ul><p>各函数对符号链接的处理：</p><table><thead><tr><th>函数</th><th>不跟随符号链接</th><th>跟随符号链接</th></tr></thead><tbody><tr><td>access</td><td></td><td>*</td></tr><tr><td>chdir</td><td></td><td>*</td></tr><tr><td>chmod</td><td></td><td>*</td></tr><tr><td>chown</td><td></td><td>*</td></tr><tr><td>creat</td><td></td><td>*</td></tr><tr><td>exec</td><td></td><td>*</td></tr><tr><td>lchown</td><td>*</td><td></td></tr><tr><td>link</td><td></td><td>*</td></tr><tr><td>lstat</td><td>*</td><td></td></tr><tr><td>open</td><td></td><td>*</td></tr><tr><td>opendir</td><td></td><td>*</td></tr><tr><td>pathconf</td><td></td><td>*</td></tr><tr><td>readlink</td><td>*</td><td></td></tr><tr><td>remove</td><td>*</td><td></td></tr><tr><td>rename</td><td>*</td><td></td></tr><tr><td>stat</td><td></td><td>*</td></tr><tr><td>truncate</td><td></td><td>*</td></tr><tr><td>unlink</td><td>*</td><td></td></tr></tbody></table><h3 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h3><p>可以用symlink或symlinkat函数创建一个符号链接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>函数创建了一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath已经存在。并且actualpath和sympath并不需要位于同一文件系统中。  </p><p>应为open函数跟随符号链接，所以需要一种方法打开该链接本身，并读取该链接中的名字。readlink和readlinkat函数提供了这种功能。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回读取的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>  两个函数组合了open、read和close的所有操作。如果函数成功执行，则返回读入buf的字节数。在buf中返回的符号链接的内容不以null字节终止。</p><h3 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h3><p>每个文件维护3个时间字段，他们的意义于下表所示。  </p><table><thead><tr><th>字段</th><th>说明</th><th>例子</th><th>ls(1)选项</th></tr></thead><tbody><tr><td>st_atime</td><td>文件数据的最后访问时间</td><td>read</td><td>-u</td></tr><tr><td>st_mtime</td><td>文件数据的最后修改时间</td><td>write</td><td>默认</td></tr><tr><td>st_ctime</td><td>i节点状态的最后更改时间</td><td>chmod、chown</td><td>-c</td></tr></tbody></table><h3 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h3><p>一个文件的访问和修改时间可以用以下几个函数更改。futimens和utimensat函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数的times数组参数的第一个元素包含访问时间，第二个元素包含修改时间。这两个时间值是日历时间，即自特定时间（1970年1月1日 00:00:00）以来经过的秒数。不足秒的部分用纳秒表示。</p><p>时间戳可以按下列4中方式之一进行。</p><ol><li>如果times参数是一个空指针，则访问使劲按和修改时间两者都设置为当前时间。</li><li>如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_NOW，相应的事件戳就设置为当前时间，忽略相应的tv_sec字段。</li><li>如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_OMIT，相应的事件戳保持不变，忽略相应的tv_sec字段。</li><li>如果times参数指向两个timespec结构的数组，且tv_nsec字段的值既不是UTIME_NOW也不是UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的时间戳设置为相应的相应的tv_sec和tv_nsec字段的值。</li></ol><p>futimes和utimeat函数都包含在POSIX.1中，第三个函数utime包含在SUS的XSI扩展中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval time[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/* 函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><p>utimes函数对路径名进行操作。times参数是指向包含两个时间戳（访问时间和修改时间）元素的数组的指针，两个时间戳是用秒和微妙表示的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;<span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">/* microseconds 微妙 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们不能对状态更改时间st_ctime(i节点最近被修改的时间)指定一个值，因为调用utimes函数时，此字段会被自动更新。  </p><h3 id="函数mkdir、mkdirat和rmdir"><a href="#函数mkdir、mkdirat和rmdir" class="headerlink" title="函数mkdir、mkdirat和rmdir"></a>函数mkdir、mkdirat和rmdir</h3><p>用mkdir和mkdirat函数创建目录，用rmdir函数删除目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pahtname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/* 两个 */</span></span><br></pre></td></tr></table></figure><p>这两个函数创建一个新的空目录。其中，.和..目录项时自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。  </p><p>对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。</p><p>用rmdir函数可以删除一个空目录。空目录是只包含.和..这两项的目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><h3 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回指针；若出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指针；若在目录尾或出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：与dp关联的目录中的当前位置 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure><p>fdopendir函数最早出现在SUSv4中，它提供了一种方法，可以把打开文件描述符装换成目录处理函数需要的DIR结构。</p><p>telldir和seekdir函数不是基本POSIX.1标准的组成部分。他们是SUS的XSI扩展，所以可以期望所有符合UNXI系统的实现都会提供这两个函数。</p><p>定义在头文件&lt;dirent.h&gt;中的dirent结构与实现有关。实现对此结构所做的定义至少包含下列两个成员：</p><ul><li>ino_t d_ino;            /* i-node number */</li><li>char d_name[]      /* null-terminated filename */</li></ul><p>DIR结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。起作用类似于FILE结构。FILE结构由标准I/O库维护。</p><p>由opendir和fdopendir返回的指向DIR结构的指针由另外5个函数使用。opendir执行初始化操作，使第一个readdir返回目录中的第一个目录项。DIR结构由fdopendir创建时，readdir返回的第一项取决于传给fdopendir函数的文件描述符相关联的文件偏移量。注意，目录中各目录项的顺序与实现有关。它们通常并不按字符顺序排列。</p><h3 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h3><p>进程调用chdir或fchdir函数可以更改当前工作目录。  </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure><p>​    </p><p>获取当前工作目录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回buf；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure><p>必须向此函数传递两个参数，一个是缓冲区地址buf，另一个是缓冲区的长度size（以字节为单位）。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止null字节，否则返回出错。</p><h3 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h3><p>st_dev和st_rdev这两个字段经常引起混淆。有关规则很简单：</p><ul><li>每个文件西永所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev_t。主设备号标识设备驱动程序，有时编码为与其通信的外设板；次设备号标识特定的子设备。一个磁盘驱动器经常包含若干个文件系统。同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设备号却不同。</li><li>我们通常可以使用两个宏：major和minor来访问主、次设备号，大多数实现都定义这两个宏。这就意味着我们无需关心这两个数是如何存放在dev_t对象中的。</li><li>系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。</li><li>只有字符特殊文件和块特殊文件才有st_rdev值。此值包含实际设备的设备号。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数stat、fstat、fstatat和lstat&quot;&gt;&lt;a href=&quot;#函数stat、fstat、fstatat和lstat&quot; class=&quot;headerlink&quot; title=&quot;函数stat、fstat、fstatat和lstat&quot;&gt;&lt;/a&gt;函数stat、fstat、fstatat和lstat&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;restrict&lt;/span&gt; pathname, struct stat *&lt;span class=&quot;keyword&quot;&gt;restrict&lt;/span&gt; buf)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fstat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, struct stat *buf)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lstat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;keyword&quot;&gt;restrict&lt;/span&gt; pathname, struct stat* &lt;span class=&quot;keyword&quot;&gt;restrict&lt;/span&gt; buf)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fstatat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;restrict&lt;/span&gt; pathname, struct stat *&lt;span class=&quot;keyword&quot;&gt;restrict&lt;/span&gt; buf, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flag)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 所有四个函数的返回值：若成功：返回0；若出错：返回-1 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="unix环境高级编程" scheme="liuyun594@github.io/categories/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="unix" scheme="liuyun594@github.io/tags/unix/"/>
    
      <category term="笔记" scheme="liuyun594@github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>unix环境高级编程：非缓冲IO</title>
    <link href="liuyun594@github.io/2019/10/28/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%9D%9E%E7%BC%93%E5%86%B2IO/"/>
    <id>liuyun594@github.io/2019/10/28/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%9D%9E%E7%BC%93%E5%86%B2IO/</id>
    <published>2019-10-27T23:29:52.000Z</published>
    <updated>2019-11-21T05:15:26.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unix环境高级编程笔记-1"><a href="#Unix环境高级编程笔记-1" class="headerlink" title="Unix环境高级编程笔记-1"></a>Unix环境高级编程笔记-1</h2><p>最近开始读Unix环境高级编程，第一、二章就先不记了，从第三章开始。</p><h3 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 两函数返回值：若成功，返回文件描述符；若出错，返回-1。 */</span></span><br></pre></td></tr></table></figure><a id="more"></a><pre><code>我们将最后一个参数为..., ISO C 用这种方法表明余下的参数的数量及其类型是可变的，对于`open`函数而言，仅当创建新文件时才使用最后这个参数。在函数原型中将此参数防止在注释中。  `path`参数时要打开或者创建文件的名字。`oflag`参数可用来说明此函数的多个选项。用下列一个或多个常量进行“或”运算构成`oflag`参数（这些常量在&lt;fcntl.h&gt;中定义）。</code></pre><ul><li>O_RDONLY          只读打开。</li><li>O_WRONLY         只写打开.</li><li>O_RDWR              读写打开。</li></ul><blockquote><p>  大多数实现将O_RDONLY定义为0，O_WRONLY定义为1，O_RDWR定义为2，以与早期程序兼容。</p></blockquote><ul><li>O_EXEC                只执行打开。</li><li>O_SEARCH          只搜索打开（应用于目录，基本上都不支持）</li></ul><p>以上五个常量中必须指定一个且只能指定一个，下列常量是可选的。</p><ul><li>O_APPEND          每次写时都追加到文件的尾端。</li><li>O_CLOEXEC         把FD_CLOEXEC常量设置为文件描述符标志。</li><li>O_CREAT               若文件不存在则创建它。使用此项时，<code>open</code>函数需勇士说明第三个参数<code>mode</code>。</li><li>O_DIRECTORY      如果<code>path</code>不是目录则出错。</li><li>O_EXCL                  如果同时制定了O_CREAT，而文件已经存在，则出错。这使得测试和创建文件成为原子操作。</li><li>O_NOCTTY            如果<code>path</code>引用的是终端设备，则不将该设备分配作为此进程的控制终端。</li><li>O_NOFOLLOW     如果<code>path</code>引用的是一个符号链接，则出错。</li><li>O_NONBLOCK      如果<code>path</code>引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式。</li><li>O_SYNC                 是每次<code>write</code>等待物理IO操作完成，包括由该<code>write</code>引起的文件属性更新所需的I/O。</li><li>O_TRUNC              如果此文件存在，而且为只写或读写成功打开，则将其长度截断为0.</li><li>O_TTY_INIT            如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合SUS。</li></ul><p>下面两个标志也是可选的。他们是SUS(以及POSIX.1)中同步输入和输出选项的一部分。</p><ul><li>O_DSYNC             每次<code>write</code>要等待物理I/O操作完成，但是如果该写操作并不影响读取刚写入的数据，则<strong>不需等待文件属性被更新</strong>。</li><li>O_RSYNC              使每一个以文件描述符作为参数进行的<code>read</code>操作等待，直至所有对文件用一部分挂起的写操作都完成。</li></ul><p>由<code>open</code>和<code>openat</code>函数返回的描述符一定是最小的未用描述符数值。  </p><p><code>fd</code>参数把<code>open</code>和<code>openat</code>函数分开，共有三种可能性。</p><ol><li><code>path</code>参数指定的使绝对路径，在这种情况下，<code>fd</code>参数被忽略掉。</li><li><code>path</code>参数指定的使相对路径名，<code>fd</code>参数指出了相对路径名在文件系统中的开始地址。<code>fd</code>参数是通过打开相对路径名所在的目录来获取。</li><li><code>path</code>参数制定了相对路径名，<code>fd</code>参数具有特殊值 AT_FDCWD。在这种情况下。路径名在当前工作目录中获取, <code>openat</code>函数在操作上与<code>open</code>类似。</li></ol><h3 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数creat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回只写打开的文件描述符；若出错，返回-1. */</span></span><br></pre></td></tr></table></figure><p>此函数等效于：</p><p><code>open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);</code>  </p><h3 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1. */</span></span><br></pre></td></tr></table></figure><p>关闭一个文件是还会释放该进程加载该文件上的所有记录锁。  </p><p>当一个进程终止时，内核会自动关闭它所有打开文件。</p><h3 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回新的文件偏移量；若失败，返回为-1. */</span></span><br></pre></td></tr></table></figure><p>对参数<code>offset</code>的解释与参数<code>whence</code>有关.</p><ul><li><p>若<code>whence</code>是 SEEK_SET ，则将该文件的偏移量设置为据文件开始处offset个字节。</p></li><li><p>若<code>whence</code>是 SEEK_CUR，则将该文件的偏移量设置为当前值加offset，offset可谓正或负。</p></li><li><p>若<code>whence</code>是 SEEK_END，则将该文件的偏移量设置为文件长度加offset，offset可正可负。</p><pre><code> 通常，文件的当前偏移量应当是一个非负值，但是，某些设备可以能允许负的偏移量。但对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在比较 `lseek` 的返回值时应当谨慎，不要测试它是否小于0，而要测试它是否等于-1.  文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0.  </code></pre></li></ul><h3 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若以到文件尾，返回0，若出错，返回-1. */</span></span><br></pre></td></tr></table></figure><h3 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">/* 返回值：若成功返回已写字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h4 id="1-追加一个文件"><a href="#1-追加一个文件" class="headerlink" title="1. 追加一个文件"></a>1. 追加一个文件</h4><pre><code>不支持O_APPEND状态标志时，要追加，程序被携程下列格式：</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lseek(fd, <span class="number">0L</span>, <span class="number">2</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">"lseek error"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf, <span class="number">100</span>) != <span class="number">100</span>)</span><br><span class="line">    err_sys(<span class="string">"write error"</span>);</span><br></pre></td></tr></table></figure><pre><code>若两个`if`之间发生了进程切换且另一个进程对文件进行了添加，则此操作会将原来的字符覆盖。  </code></pre><h4 id="2-函数pread和pwrite"><a href="#2-函数pread和pwrite" class="headerlink" title="2. 函数pread和pwrite"></a>2. 函数pread和pwrite</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1. */</span></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回独到的字节数；若出错，返回-1. */</span></span><br></pre></td></tr></table></figure><pre><code>调用`pread`相当于调用`lseek`后调用`read`，但是`pread`又与这种顺序调用有下列重要区别。</code></pre><ul><li><p>调用<code>pread</code>时，无法中断其定位和读操作。</p></li><li><p>不更新当前文件偏移量。</p><p>  调用<code>pwrite</code>相当于调用<code>lseek</code>后调用<code>write</code>，但与他们有类似的区别。  </p></li></ul><h4 id="3-创建一个文件"><a href="#3-创建一个文件" class="headerlink" title="3. 创建一个文件"></a>3. 创建一个文件</h4><p><code>open</code>函数使用 O_CREAT 和 O_EXCL 状态描述符时检查文件是否存在和创建文件这两个操作时作为一个原子操作存在的。若没有这个原子操作，那么可能会编写下列程序：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = <span class="built_in">open</span>(pathname, O_WRONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = creat(path, mode)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"creat error"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        err_sys(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h3><p>下面两个函数都可以用来复制一个现有的文件描述符。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="comment">/* 两函数返回值：若成功，返回新的文件描述符；若出错，返回-1. */</span></span><br></pre></td></tr></table></figure><p>由<code>dup</code>返回的新文件描述符一定是当前可用文件描述符的最小值。  </p><p>对于<code>dup2</code>可以用<code>fd2</code>参数指定新的描述符值。如果<code>fd2</code>已经打开，则先将其关闭。若<code>fd</code>等于<code>fd2</code>，则<code>dup2</code>返回<code>fd2</code>，而不关闭它。否则，<code>fd2</code>的FD_CLOEXEC文件描述符标志就被清楚，这样<code>fd2</code>在进程调用<code>exec</code>时是打开状态。  </p><h3 id="函数sync、fsync和fdatasync"><a href="#函数sync、fsync和fdatasync" class="headerlink" title="函数sync、fsync和fdatasync"></a>函数sync、fsync和fdatasync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>sync</code>只是将所有修改过的快缓冲区排入写队列，然后就返回，它并不等待世界写磁盘操作结束。  </p><p><code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。  </p><p><code>fdatasync</code>函数类似于<code>fsync</code>，但他只影响文件的数据部分。除数据外，<code>fsync</code>还会同步更新文件的属性。  </p><h3 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，则依赖于cmd, 若出错，返回-1. */</span></span><br></pre></td></tr></table></figure><p><code>fcntl</code>函数共有以下5中功能。</p><ol><li>复制一个已有的描述符(<code>cmd</code>=F_DUPFD或F_DUPFD_CLOEXEC)。</li><li>获取/设置文件描述符标志(<code>cmd</code> = F_GETFD或F_SETFD)。</li><li>获取/设置文件状态标志(<code>cmd</code> = F_GETFL或F_GETFL)。</li><li>获取/设置异步I/O所有权（<code>cmd</code> = F_GETOWN或F_SETOWN）。</li><li>获取/设置记录锁(<code>cmd</code> = F_GETLK、F_SETLK或F_SETLKW)。</li></ol><p><img src="https://mzgmzg.github.io/images/unix_programing/fcnlt1.jpg" alt="fcntl1"></p><p><img src="https://mzgmzg.github.io/images/unix_programing/fcntl2.jpg" alt="fcntl2"></p><h3 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* System V */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; /*BSD and Linux*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：出错返回-1，否则其他值。 */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Unix环境高级编程笔记-1&quot;&gt;&lt;a href=&quot;#Unix环境高级编程笔记-1&quot; class=&quot;headerlink&quot; title=&quot;Unix环境高级编程笔记-1&quot;&gt;&lt;/a&gt;Unix环境高级编程笔记-1&lt;/h2&gt;&lt;p&gt;最近开始读Unix环境高级编程，第一、二章就先不记了，从第三章开始。&lt;/p&gt;&lt;h3 id=&quot;函数open和openat&quot;&gt;&lt;a href=&quot;#函数open和openat&quot; class=&quot;headerlink&quot; title=&quot;函数open和openat&quot;&gt;&lt;/a&gt;函数open和openat&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oflag, ... &lt;span class=&quot;comment&quot;&gt;/* mode_t mode */&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* path, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oflag, ... &lt;span class=&quot;comment&quot;&gt;/* mode_t mode */&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 两函数返回值：若成功，返回文件描述符；若出错，返回-1。 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="unix环境高级编程" scheme="liuyun594@github.io/categories/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="unix" scheme="liuyun594@github.io/tags/unix/"/>
    
      <category term="笔记" scheme="liuyun594@github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
